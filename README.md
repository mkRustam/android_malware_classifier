<br/>
Todo: Дописать про utils

<br/>
Структура датасета:

* КлассВируса-1
  * 1.apk
  * 2.apk
* КлассВируса-2
  * 1.apk
  * 2.apk

<br/>
Все подходы хранятся в папке approaches:

## Image<br/>
Классификация по изображению. В качестве изображения выступают первые N байт APK файла. Минус подхода заключается в том, что мы не знаем где именно начинается вредосный код, и всё изображение может состоять на основе обычного (не вредоносного) кода.

Файлы:
  * asmimage: извлечение фич
  * firstrandomforest: классификация вируса

## Graph<br/>
Построение графика на основне API calls. В качестве вершин выступают package'ы из которого и в который происходит API вызов. Затем обе вершины (начальная и конечная) превращаются в хэш. Несколько таких хэшей образуют одну фичу (N-gram). Все вызовы из пользовательских классов будут исходить из одной вершины. Итогом будет JSON файл из этих хэшей.

Например:
1) com.user.package =вызывает=> java.util.Arrays
1) com.user.package =вызывает=> java.util.List
2) "com.user.package+java.util.Arrays"=HASH1
2) "com.user.package+java.util.List"=HASH2
3) \[HASH1, HASH2\]

Файлы:
  * graph_pre_processing: превращение всех apk файлов в json
  * graph_train_model: создание CSV файла с graph фичами
  * graph_predict: классификация вируса (apk файл)

## Grayscaled_image<br/>
Классификация по изображению. В качестве изображения выступают JSON файлы, полученные методом Graph.
  * converter: конвертация json файла (полученного с помощью graph) в изображение
  * img_train_model2: тренировка и сохранение модели для последующей загрузки и использования для классификации вируса

## Opcode<br/>
Самый эффективный метод классификации. Превращает весь apk файл в последовательность opcode вызовов. Несколько таких вызовов составляют одну фичу (N-gram).
  * opcode_n-gram: извлечение opcode n-gram features и сохранение их в csv файл
  * secondrandomforest: классификация вируса (apk файл)
