'''
Created on 15/nov/2014

@author: francesco mercaldo
'''
import sys
import os
import zipfile
import collections
import shutil
from androguard.core.bytecodes import apk
from utils import constants
from apkil import smali

sys.setrecursionlimit(4500)


def baksmali(apk_dir, smali_dir):
    dex = '%s%s' % (apk_dir, '/classes.dex')
    baksmali = '%s %s %s %s %s "%s" "%s"' % ('java', '-jar', constants.BACKSMALI_PATH, '-b', '-o', smali_dir, dex)
    os.system(baksmali)


def extract_file(apk_filename, extension, out_dir):
    if zipfile.is_zipfile(apk_filename):
        zf = zipfile.ZipFile(apk_filename, 'r')
        for name in zf.namelist():
            if name.find(extension) != -1:
                zf.extract(name, out_dir)
    else:
        print apk_filename, ' is not a valid APK'


def extract_code(smali_tree, invoke_limit):
    classes_map = dict()
    ins_map = dict()
    invoke_limit_map = dict()
    smali_classes = smali_tree.classes
    for c in smali_classes:
        if not (c.name.startswith('Landroid') or c.name.startswith('Ljava')):
            classes_map[c.name] = c
            for m in c.methods:
                ins_map['%s-%s' % (c.name, m.descriptor)] = m.insns
                invoke_limit_map['%s-%s' % (c.name, m.descriptor)] = invoke_limit
    return (classes_map, ins_map, invoke_limit_map)


def add_insns(insns_list, class_name, method_descriptor, classes_map, ins_map):
    smali_class = None
    if class_name in classes_map:
        smali_class = classes_map[class_name]
    if not smali_class is None:
        superclass_name = smali_class.super_name
        interfaces = smali_class.interfaces
        method_insns = None
        if '%s-%s' % (class_name, method_descriptor) in ins_map:
            method_insns = ins_map['%s-%s' % (class_name, method_descriptor)]
        elif '%s-%s' % (superclass_name, method_descriptor) in ins_map:
            method_insns = ins_map['%s-%s' % (superclass_name, method_descriptor)]
        else:
            for i in interfaces:
                if '%s-%s' % (i, method_descriptor) in ins_map:
                    method_insns = ins_map['%s-%s' % (i, method_descriptor)]
                    break
        if not method_insns is None:
            for ins in method_insns:
                insns_list.append(ins.opcode_name)
                if not ins.fmt == '':
                    invoked_class = ins.obj.method_desc[0:ins.obj.method_desc.index("->")]
                    invoked_method = ins.obj.method_desc[ins.obj.method_desc.index("->") + 2:len(ins.obj.method_desc)]
                    add_insns(insns_list, invoked_class, invoked_method, classes_map, ins_map)


def add_insns2(insns_list, temp_invoke_map, class_name, method_descriptor, classes_map, ins_map, invoke_limit_map,
               recursion_depth, count=0):
    smali_class = None
    if class_name in classes_map:
        smali_class = classes_map[class_name]
    if not smali_class is None:
        superclass_name = smali_class.super_name
        interfaces = smali_class.interfaces
        method_insns = None
        if '%s-%s' % (class_name, method_descriptor) in ins_map:
            method_insns = get_method_insns(class_name, method_descriptor, ins_map, invoke_limit_map)
        elif '%s-%s' % (superclass_name, method_descriptor) in ins_map:
            method_insns = get_method_insns(superclass_name, method_descriptor, ins_map, invoke_limit_map)
        else:
            for i in interfaces:
                if '%s-%s' % (i, method_descriptor) in ins_map:
                    method_insns = get_method_insns(i, method_descriptor, ins_map, invoke_limit_map)
                    break

        if not method_insns is None:
            for ins in method_insns:
                insns_list.append(ins.opcode_name)
                if not ins.fmt == '':
                    invoked_class = ins.obj.method_desc[0:ins.obj.method_desc.index("->")]
                    invoked_method = ins.obj.method_desc[ins.obj.method_desc.index("->") + 2:len(ins.obj.method_desc)]
                    if not (invoked_class.startswith('Landroid') or invoked_class.startswith('Ljava')):
                        if count > recursion_depth:
                            temp_invoke_map[len(insns_list) - 1] = ins
                        else:
                            add_insns2(insns_list, temp_invoke_map, invoked_class, invoked_method, classes_map, ins_map,
                                       invoke_limit_map, recursion_depth, count + 1)


def ins_sequence(main_activity, min_version, smali_dir, ins_count):
    smali_code = smali.SmaliTree(min_version, smali_dir)
    classes_map, ins_map, ins_count_map = extract_code(smali_code, ins_count)
    insns_list = collections.deque()
    main_class = classes_map['%s%s%s' % ('L', main_activity.replace('.', '/'), ';')]
    super_class = None
    if main_class.super_name in classes_map:
        super_class = classes_map[main_class.super_name]
    interfaces = main_class.interfaces
    onCreate_method = None
    target_class = None
    for m in main_class.methods:
        if m.name == 'onCreate':
            onCreate_method = m
            target_class = main_class
            break
    if onCreate_method is None and not super_class is None:
        for m in super_class.methods:
            if m.name == 'onCreate':
                onCreate_method = m
                target_class = super_class
                break
    if onCreate_method is None:
        for i in interfaces:
            for m in i.methods:
                if m.name == 'onCreate':
                    onCreate_method = m
                    target_class = i
                    break
    # print 'onCreate method found in ', target_class.name
    if not onCreate_method is None and not target_class.name.startswith('Landroid'):
        add_insns(insns_list, main_class.name, onCreate_method.descriptor, classes_map, ins_map)
    else:
        print 'onCreate not found.'
    print 'list size: ', len(insns_list)
    return insns_list


def ins_sequence2(main_activity, min_version, smali_dir, invoke_limit, recursion_depth):
    smali_code = smali.SmaliTree(min_version, smali_dir)
    classes_map, ins_map, invoke_limit_map = extract_code(smali_code, invoke_limit)
    insns_list = collections.deque()
    temp_insns = collections.deque()
    class_name = '%s%s%s' % ('L', main_activity.replace('.', '/'), ';')
    print 'Main Class: ', class_name
    if class_name in classes_map:
        main_class = classes_map[class_name]
    else:
        return
    super_class = None
    if main_class.super_name in classes_map:
        super_class = classes_map[main_class.super_name]
    interfaces = main_class.interfaces
    onCreate_method = None
    target_class = None
    for m in main_class.methods:
        if m.name == 'onCreate':
            onCreate_method = m
            target_class = main_class
            break
    if onCreate_method is None and not super_class is None:
        for m in super_class.methods:
            if m.name == 'onCreate':
                onCreate_method = m
                target_class = super_class
                break
    if onCreate_method is None:
        for i in interfaces:
            for m in i.methods:
                if m.name == 'onCreate':
                    onCreate_method = m
                    target_class = i
                    break
    # print 'onCreate method found in ', target_class.name
    if not onCreate_method is None:
        temp_invoke_map = {}
        rec = 0
        print 'Recursion step: ', rec, ' - list size: ', len(insns_list), 'invoke_map: ', len(temp_invoke_map)
        add_insns2(temp_insns, temp_invoke_map, target_class.name, onCreate_method.descriptor, classes_map, ins_map,
                   invoke_limit_map, recursion_depth)
        rec = rec + 1
        print 'Recursion step: ', rec, ' - list size: ', len(insns_list), 'invoke_map: ', len(temp_invoke_map)
        while (temp_invoke_map):
            insns_list = collections.deque()
            rec = rec + 1
            for i in xrange(0, len(temp_insns)):
                insns_list.append(temp_insns[i])
                if i in temp_invoke_map:
                    ins = temp_invoke_map[i]

                    invoked_class = ins.obj.method_desc[0:ins.obj.method_desc.index("->")]
                    invoked_method = ins.obj.method_desc[ins.obj.method_desc.index("->") + 2:len(ins.obj.method_desc)]
                    temp_invoke_map.pop(i, None)
                    add_insns2(insns_list, temp_invoke_map, invoked_class, invoked_method, classes_map, ins_map,
                               invoke_limit_map, recursion_depth)
            temp_insns = list(insns_list)
            del insns_list
            print 'Recursion step: ', rec, ' - list size: ', len(temp_insns), 'invoke_map: ', len(temp_invoke_map)
    return temp_insns


def get_method_insns(class_name, method_descriptor, ins_map, invoke_limit_map):
    key = '%s-%s' % (class_name, method_descriptor)
    method_insns = None
    count = invoke_limit_map.get(key)
    if count > 0:
        invoke_limit_map[key] = count - 1
        method_insns = ins_map.get(key)
    return method_insns


def seq_extraction(apk_path, invoke_limit, recursion_depth):
    print 'Opening ', apk_path, '...'
    apk_file = apk.APK(apk_path)
    apk_dir = apk_path[0:-4]
    smali_dir = '%s%s' % (apk_dir, '/classes')
    min_version = 7
    if not apk_file.get_min_sdk_version() is None:
        int(apk_file.get_min_sdk_version())
    main_activity = apk_file.get_main_activity()
    if main_activity is None:
        print 'Searching main activity...'
        act = apk_file.get_activities()
        if len(act) == 0:
            print 'No main activity found, ', len(act)
            return
        main_activity = act[0]
    print 'Main activity: ', main_activity
    extract_file(apk_path, 'dex', apk_dir)
    baksmali(apk_dir, smali_dir)
    insns_list = None
    if recursion_depth == 0:
        insns_list = ins_sequence(main_activity, min_version, smali_dir, invoke_limit)
    else:
        print 'recursion: ', recursion_depth
        insns_list = ins_sequence2(main_activity, min_version, smali_dir, invoke_limit, recursion_depth)
    if not insns_list is None:
        out_file = open('%s%s' % (apk_dir, '/opcode_sequence.txt'), 'w')
        for i in insns_list:
            out_file.write('%s\n' % i)
        out_file.close()
    else:
        print '....no opcode sequence extracted'


def get_seq_extraction(apk_path, invoke_limit, recursion_depth):
    print 'Opening ', apk_path, '...'
    apk_file = apk.APK(apk_path)
    apk_dir = apk_path[0:-4]
    smali_dir = '%s%s' % (apk_dir, '/classes')
    min_version = 7
    if not apk_file.get_min_sdk_version() is None:
        int(apk_file.get_min_sdk_version())
    main_activity = apk_file.get_main_activity()
    if main_activity is None:
        print 'Searching main activity...'
        act = apk_file.get_activities()
        if len(act) == 0:
            print 'No main activity found, ', len(act)
            return
        main_activity = act[0]
    print 'Main activity: ', main_activity
    extract_file(apk_path, 'dex', apk_dir)
    baksmali(apk_dir, smali_dir)
    insns_list = None
    if recursion_depth == 0:
        insns_list = ins_sequence(main_activity, min_version, smali_dir, invoke_limit)
    else:
        print 'recursion: ', recursion_depth
        insns_list = ins_sequence2(main_activity, min_version, smali_dir, invoke_limit, recursion_depth)

    if insns_list is None:
        print '....no opcode sequence extracted'

    if os.path.isdir(apk_dir):
        shutil.rmtree(apk_dir)

    return insns_list


if __name__ == '__main__':
    if len(sys.argv) != 4:
        print 'Usage: opcode_sequence.py [path]apk_filename recursion_depth, invoke_limit'
        sys.exit()
    apk_path = sys.argv[1]
    recursion_depth = int(sys.argv[2])
    invoke_limit = int(sys.argv[3])
    seq_extraction(apk_path, invoke_limit, recursion_depth)
